{"version":3,"file":"js/78.f823856e.js","mappings":";;;GAMA,MAAMA,EAAuB,cACvBC,EAA+B,cAC/BC,EAA6B,2BAQ7BC,EAAuB,GAAGF,MAAiCC,IAC3DE,EAAgBC,GAAOA,EAAGC,UAAYN,EAWtCO,EAAmBC,MAAOH,GACxBD,EAAaC,UACP,IAAII,SAASC,IAAY,IAAAC,GAAiBN,EAAIK,KAC7CL,EAAGE,oBAEPF,EAqBLO,EAAyBP,GACpBA,EAAGQ,QAAQV,GAMhBW,EAAc,CAACT,EAAIU,KACrB,GAAIX,EAAaC,GAAK,CAClB,MAAMW,EAAUX,EAChB,OAAOW,EAAQF,YAAYC,EAC/B,CACA,OAAON,QAAQC,QAAQL,EAAGY,SAAS,CAC/BC,IAAK,EACLC,KAAM,EACNC,SAAUL,EAAa,EAAI,SAAW,SACvC,EAMDM,EAAgB,CAAChB,EAAIiB,EAAGC,EAAGR,KAC7B,GAAIX,EAAaC,GAAK,CAClB,MAAMW,EAAUX,EAChB,OAAOW,EAAQK,cAAcC,EAAGC,EAAGR,EACvC,CACA,OAAON,QAAQC,QAAQL,EAAGmB,SAAS,CAC/BN,IAAKK,EACLJ,KAAMG,EACNF,SAAUL,EAAa,EAAI,SAAW,SACvC,C;;;;AC9EP,MAAMU,EAAiB,KACnB,MAAMC,EAAMC,OACZD,EAAIE,iBAAiB,aAAa,MAC9B,SAAS,KACL,MAAMC,EAAQH,EAAII,WACZC,EAASL,EAAIM,YACb3B,EAAK4B,SAASC,iBAAiBL,EAAQ,EAAGE,EAAS,GACzD,IAAK1B,EACD,OAEJ,MAAM8B,GAAY,OAAsB9B,GACpC8B,GACA,IAAI1B,SAASC,IAAY,IAAAC,GAAiBwB,EAAWzB,KAAU0B,MAAK,MAChE,SAAU5B,UAQN2B,EAAUE,MAAMC,YAAY,aAAc,gBACpC,IAAAC,GAAYJ,EAAW,KAC7BA,EAAUE,MAAMG,eAAe,aAAa,GAC9C,GAEV,GACF,GACJ,C","sources":["webpack://is-it-my-birthday/./node_modules/@ionic/core/components/index8.js","webpack://is-it-my-birthday/./node_modules/@ionic/core/components/status-tap.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { c as componentOnReady } from './helpers.js';\r\nimport { b as printRequiredElementError } from './index6.js';\r\n\r\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\r\nconst ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\r\nconst ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\r\n/**\r\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\r\n *\r\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\r\n * scroll events. With virtual scroll implementations this will be the host element for\r\n * the scroll viewport.\r\n */\r\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\r\nconst isIonContent = (el) => el.tagName === ION_CONTENT_TAG_NAME;\r\n/**\r\n * Waits for the element host fully initialize before\r\n * returning the inner scroll element.\r\n *\r\n * For `ion-content` the scroll target will be the result\r\n * of the `getScrollElement` function.\r\n *\r\n * For custom implementations it will be the element host\r\n * or a selector within the host, if supplied through `scrollTarget`.\r\n */\r\nconst getScrollElement = async (el) => {\r\n    if (isIonContent(el)) {\r\n        await new Promise((resolve) => componentOnReady(el, resolve));\r\n        return el.getScrollElement();\r\n    }\r\n    return el;\r\n};\r\n/**\r\n * Queries the element matching the selector for IonContent.\r\n * See ION_CONTENT_SELECTOR for the selector used.\r\n */\r\nconst findIonContent = (el) => {\r\n    /**\r\n     * First we try to query the custom scroll host selector in cases where\r\n     * the implementation is using an outer `ion-content` with an inner custom\r\n     * scroll container.\r\n     */\r\n    const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\r\n    if (customContentHost) {\r\n        return customContentHost;\r\n    }\r\n    return el.querySelector(ION_CONTENT_SELECTOR);\r\n};\r\n/**\r\n * Queries the closest element matching the selector for IonContent.\r\n */\r\nconst findClosestIonContent = (el) => {\r\n    return el.closest(ION_CONTENT_SELECTOR);\r\n};\r\n/**\r\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\r\n * using the public API `scrollToTop` with a duration.\r\n */\r\nconst scrollToTop = (el, durationMs) => {\r\n    if (isIonContent(el)) {\r\n        const content = el;\r\n        return content.scrollToTop(durationMs);\r\n    }\r\n    return Promise.resolve(el.scrollTo({\r\n        top: 0,\r\n        left: 0,\r\n        behavior: durationMs > 0 ? 'smooth' : 'auto',\r\n    }));\r\n};\r\n/**\r\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\r\n * using the public API `scrollByPoint` with a duration.\r\n */\r\nconst scrollByPoint = (el, x, y, durationMs) => {\r\n    if (isIonContent(el)) {\r\n        const content = el;\r\n        return content.scrollByPoint(x, y, durationMs);\r\n    }\r\n    return Promise.resolve(el.scrollBy({\r\n        top: y,\r\n        left: x,\r\n        behavior: durationMs > 0 ? 'smooth' : 'auto',\r\n    }));\r\n};\r\n/**\r\n * Prints an error informing developers that an implementation requires an element to be used\r\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\r\n */\r\nconst printIonContentErrorMsg = (el) => {\r\n    return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\r\n};\r\n/**\r\n * Several components in Ionic need to prevent scrolling\r\n * during a gesture (card modal, range, item sliding, etc).\r\n * Use this utility to account for ion-content and custom content hosts.\r\n */\r\nconst disableContentScrollY = (contentEl) => {\r\n    if (isIonContent(contentEl)) {\r\n        const ionContent = contentEl;\r\n        const initialScrollY = ionContent.scrollY;\r\n        ionContent.scrollY = false;\r\n        /**\r\n         * This should be passed into resetContentScrollY\r\n         * so that we can revert ion-content's scrollY to the\r\n         * correct state. For example, if scrollY = false\r\n         * initially, we do not want to enable scrolling\r\n         * when we call resetContentScrollY.\r\n         */\r\n        return initialScrollY;\r\n    }\r\n    else {\r\n        contentEl.style.setProperty('overflow', 'hidden');\r\n        return true;\r\n    }\r\n};\r\nconst resetContentScrollY = (contentEl, initialScrollY) => {\r\n    if (isIonContent(contentEl)) {\r\n        contentEl.scrollY = initialScrollY;\r\n    }\r\n    else {\r\n        contentEl.style.removeProperty('overflow');\r\n    }\r\n};\r\n\r\nexport { ION_CONTENT_CLASS_SELECTOR as I, findClosestIonContent as a, ION_CONTENT_ELEMENT_SELECTOR as b, scrollByPoint as c, disableContentScrollY as d, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, resetContentScrollY as r, scrollToTop as s };\r\n","/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { readTask, writeTask } from '@stencil/core/internal/client';\r\nimport { a as findClosestIonContent, s as scrollToTop } from './index8.js';\r\nimport { c as componentOnReady } from './helpers.js';\r\n\r\nconst startStatusTap = () => {\r\n    const win = window;\r\n    win.addEventListener('statusTap', () => {\r\n        readTask(() => {\r\n            const width = win.innerWidth;\r\n            const height = win.innerHeight;\r\n            const el = document.elementFromPoint(width / 2, height / 2);\r\n            if (!el) {\r\n                return;\r\n            }\r\n            const contentEl = findClosestIonContent(el);\r\n            if (contentEl) {\r\n                new Promise((resolve) => componentOnReady(contentEl, resolve)).then(() => {\r\n                    writeTask(async () => {\r\n                        /**\r\n                         * If scrolling and user taps status bar,\r\n                         * only calling scrollToTop is not enough\r\n                         * as engines like WebKit will jump the\r\n                         * scroll position back down and complete\r\n                         * any in-progress momentum scrolling.\r\n                         */\r\n                        contentEl.style.setProperty('--overflow', 'hidden');\r\n                        await scrollToTop(contentEl, 300);\r\n                        contentEl.style.removeProperty('--overflow');\r\n                    });\r\n                });\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\nexport { startStatusTap };\r\n"],"names":["ION_CONTENT_TAG_NAME","ION_CONTENT_ELEMENT_SELECTOR","ION_CONTENT_CLASS_SELECTOR","ION_CONTENT_SELECTOR","isIonContent","el","tagName","getScrollElement","async","Promise","resolve","c","findClosestIonContent","closest","scrollToTop","durationMs","content","scrollTo","top","left","behavior","scrollByPoint","x","y","scrollBy","startStatusTap","win","window","addEventListener","width","innerWidth","height","innerHeight","document","elementFromPoint","contentEl","then","style","setProperty","s","removeProperty"],"sourceRoot":""}