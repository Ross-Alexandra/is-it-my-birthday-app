{"version":3,"file":"js/980.146c3de7.js","mappings":"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","sources":["webpack://is-it-my-birthday/./node_modules/@ionic/core/components/animation.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win } from './index5.js';\r\nimport { r as raf } from './helpers.js';\r\n\r\nlet animationPrefix;\r\n/**\r\n * Web Animations requires hyphenated CSS properties\r\n * to be written in camelCase when animating\r\n */\r\nconst processKeyframes = (keyframes) => {\r\n    keyframes.forEach((keyframe) => {\r\n        for (const key in keyframe) {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            if (keyframe.hasOwnProperty(key)) {\r\n                const value = keyframe[key];\r\n                if (key === 'easing') {\r\n                    const newKey = 'animation-timing-function';\r\n                    keyframe[newKey] = value;\r\n                    delete keyframe[key];\r\n                }\r\n                else {\r\n                    const newKey = convertCamelCaseToHypen(key);\r\n                    if (newKey !== key) {\r\n                        keyframe[newKey] = value;\r\n                        delete keyframe[key];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return keyframes;\r\n};\r\nconst convertCamelCaseToHypen = (str) => {\r\n    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\r\n};\r\nconst getAnimationPrefix = (el) => {\r\n    if (animationPrefix === undefined) {\r\n        const supportsUnprefixed = el.style.animationName !== undefined;\r\n        const supportsWebkitPrefix = el.style.webkitAnimationName !== undefined;\r\n        animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? '-webkit-' : '';\r\n    }\r\n    return animationPrefix;\r\n};\r\nconst setStyleProperty = (element, propertyName, value) => {\r\n    const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\r\n    element.style.setProperty(prefix + propertyName, value);\r\n};\r\nconst removeStyleProperty = (element, propertyName) => {\r\n    const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\r\n    element.style.removeProperty(prefix + propertyName);\r\n};\r\nconst animationEnd = (el, callback) => {\r\n    let unRegTrans;\r\n    const opts = { passive: true };\r\n    const unregister = () => {\r\n        if (unRegTrans) {\r\n            unRegTrans();\r\n        }\r\n    };\r\n    const onTransitionEnd = (ev) => {\r\n        if (el === ev.target) {\r\n            unregister();\r\n            callback(ev);\r\n        }\r\n    };\r\n    if (el) {\r\n        el.addEventListener('webkitAnimationEnd', onTransitionEnd, opts);\r\n        el.addEventListener('animationend', onTransitionEnd, opts);\r\n        unRegTrans = () => {\r\n            el.removeEventListener('webkitAnimationEnd', onTransitionEnd, opts);\r\n            el.removeEventListener('animationend', onTransitionEnd, opts);\r\n        };\r\n    }\r\n    return unregister;\r\n};\r\n// TODO(FW-2832): type\r\nconst generateKeyframeRules = (keyframes = []) => {\r\n    return keyframes\r\n        .map((keyframe) => {\r\n        const offset = keyframe.offset;\r\n        const frameString = [];\r\n        for (const property in keyframe) {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            if (keyframe.hasOwnProperty(property) && property !== 'offset') {\r\n                frameString.push(`${property}: ${keyframe[property]};`);\r\n            }\r\n        }\r\n        return `${offset * 100}% { ${frameString.join(' ')} }`;\r\n    })\r\n        .join(' ');\r\n};\r\nconst keyframeIds = [];\r\nconst generateKeyframeName = (keyframeRules) => {\r\n    let index = keyframeIds.indexOf(keyframeRules);\r\n    if (index < 0) {\r\n        index = keyframeIds.push(keyframeRules) - 1;\r\n    }\r\n    return `ion-animation-${index}`;\r\n};\r\nconst getStyleContainer = (element) => {\r\n    // getRootNode is not always available in SSR environments.\r\n    // TODO(FW-2832): types\r\n    const rootNode = element.getRootNode !== undefined ? element.getRootNode() : element;\r\n    return rootNode.head || rootNode;\r\n};\r\nconst createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {\r\n    var _a;\r\n    const styleContainer = getStyleContainer(element);\r\n    const keyframePrefix = getAnimationPrefix(element);\r\n    const existingStylesheet = styleContainer.querySelector('#' + keyframeName);\r\n    if (existingStylesheet) {\r\n        return existingStylesheet;\r\n    }\r\n    const stylesheet = ((_a = element.ownerDocument) !== null && _a !== void 0 ? _a : document).createElement('style');\r\n    stylesheet.id = keyframeName;\r\n    stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;\r\n    styleContainer.appendChild(stylesheet);\r\n    return stylesheet;\r\n};\r\nconst addClassToArray = (classes = [], className) => {\r\n    if (className !== undefined) {\r\n        const classNameToAppend = Array.isArray(className) ? className : [className];\r\n        return [...classes, ...classNameToAppend];\r\n    }\r\n    return classes;\r\n};\r\n\r\nconst createAnimation = (animationId) => {\r\n    let _delay;\r\n    let _duration;\r\n    let _easing;\r\n    let _iterations;\r\n    let _fill;\r\n    let _direction;\r\n    let _keyframes = [];\r\n    let beforeAddClasses = [];\r\n    let beforeRemoveClasses = [];\r\n    let initialized = false;\r\n    let parentAnimation;\r\n    let beforeStylesValue = {};\r\n    let afterAddClasses = [];\r\n    let afterRemoveClasses = [];\r\n    let afterStylesValue = {};\r\n    let numAnimationsRunning = 0;\r\n    let shouldForceLinearEasing = false;\r\n    let shouldForceSyncPlayback = false;\r\n    let cssAnimationsTimerFallback;\r\n    let forceDirectionValue;\r\n    let forceDurationValue;\r\n    let forceDelayValue;\r\n    let willComplete = true;\r\n    let finished = false;\r\n    let shouldCalculateNumAnimations = true;\r\n    let keyframeName;\r\n    let ani;\r\n    let paused = false;\r\n    const id = animationId;\r\n    const onFinishCallbacks = [];\r\n    const onFinishOneTimeCallbacks = [];\r\n    const onStopOneTimeCallbacks = [];\r\n    const elements = [];\r\n    const childAnimations = [];\r\n    const stylesheets = [];\r\n    const _beforeAddReadFunctions = [];\r\n    const _beforeAddWriteFunctions = [];\r\n    const _afterAddReadFunctions = [];\r\n    const _afterAddWriteFunctions = [];\r\n    const webAnimations = [];\r\n    const supportsAnimationEffect = typeof AnimationEffect === 'function' ||\r\n        (win !== undefined && typeof win.AnimationEffect === 'function');\r\n    const supportsWebAnimations = typeof Element === 'function' &&\r\n        typeof Element.prototype.animate === 'function' &&\r\n        supportsAnimationEffect;\r\n    const ANIMATION_END_FALLBACK_PADDING_MS = 100;\r\n    const getWebAnimations = () => {\r\n        return webAnimations;\r\n    };\r\n    const destroy = (clearStyleSheets) => {\r\n        childAnimations.forEach((childAnimation) => {\r\n            childAnimation.destroy(clearStyleSheets);\r\n        });\r\n        cleanUp(clearStyleSheets);\r\n        elements.length = 0;\r\n        childAnimations.length = 0;\r\n        _keyframes.length = 0;\r\n        clearOnFinish();\r\n        initialized = false;\r\n        shouldCalculateNumAnimations = true;\r\n        return ani;\r\n    };\r\n    /**\r\n     * Cancels any Web Animations, removes\r\n     * any animation properties from the\r\n     * animation's elements, and removes the\r\n     * animation's stylesheets from the DOM.\r\n     */\r\n    const cleanUp = (clearStyleSheets) => {\r\n        cleanUpElements();\r\n        if (clearStyleSheets) {\r\n            cleanUpStyleSheets();\r\n        }\r\n    };\r\n    const resetFlags = () => {\r\n        shouldForceLinearEasing = false;\r\n        shouldForceSyncPlayback = false;\r\n        shouldCalculateNumAnimations = true;\r\n        forceDirectionValue = undefined;\r\n        forceDurationValue = undefined;\r\n        forceDelayValue = undefined;\r\n        numAnimationsRunning = 0;\r\n        finished = false;\r\n        willComplete = true;\r\n        paused = false;\r\n    };\r\n    const isRunning = () => {\r\n        return numAnimationsRunning !== 0 && !paused;\r\n    };\r\n    /**\r\n     * @internal\r\n     * Remove a callback from a chosen callback array\r\n     * @param callbackToRemove: A reference to the callback that should be removed\r\n     * @param callbackObjects: An array of callbacks that callbackToRemove should be removed from.\r\n     */\r\n    const clearCallback = (callbackToRemove, callbackObjects) => {\r\n        const index = callbackObjects.findIndex((callbackObject) => callbackObject.c === callbackToRemove);\r\n        if (index > -1) {\r\n            callbackObjects.splice(index, 1);\r\n        }\r\n    };\r\n    /**\r\n     * @internal\r\n     * Add a callback to be fired when an animation is stopped/cancelled.\r\n     * @param callback: A reference to the callback that should be fired\r\n     * @param opts: Any options associated with this particular callback\r\n     */\r\n    const onStop = (callback, opts) => {\r\n        onStopOneTimeCallbacks.push({ c: callback, o: opts });\r\n        return ani;\r\n    };\r\n    const onFinish = (callback, opts) => {\r\n        const callbacks = (opts === null || opts === void 0 ? void 0 : opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;\r\n        callbacks.push({ c: callback, o: opts });\r\n        return ani;\r\n    };\r\n    const clearOnFinish = () => {\r\n        onFinishCallbacks.length = 0;\r\n        onFinishOneTimeCallbacks.length = 0;\r\n        return ani;\r\n    };\r\n    /**\r\n     * Cancels any Web Animations and removes\r\n     * any animation properties from the\r\n     * the animation's elements.\r\n     */\r\n    const cleanUpElements = () => {\r\n        if (supportsWebAnimations) {\r\n            webAnimations.forEach((animation) => {\r\n                animation.cancel();\r\n            });\r\n            webAnimations.length = 0;\r\n        }\r\n        else {\r\n            const elementsArray = elements.slice();\r\n            raf(() => {\r\n                elementsArray.forEach((element) => {\r\n                    removeStyleProperty(element, 'animation-name');\r\n                    removeStyleProperty(element, 'animation-duration');\r\n                    removeStyleProperty(element, 'animation-timing-function');\r\n                    removeStyleProperty(element, 'animation-iteration-count');\r\n                    removeStyleProperty(element, 'animation-delay');\r\n                    removeStyleProperty(element, 'animation-play-state');\r\n                    removeStyleProperty(element, 'animation-fill-mode');\r\n                    removeStyleProperty(element, 'animation-direction');\r\n                });\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Removes the animation's stylesheets\r\n     * from the DOM.\r\n     */\r\n    const cleanUpStyleSheets = () => {\r\n        stylesheets.forEach((stylesheet) => {\r\n            /**\r\n             * When sharing stylesheets, it's possible\r\n             * for another animation to have already\r\n             * cleaned up a particular stylesheet\r\n             */\r\n            if (stylesheet === null || stylesheet === void 0 ? void 0 : stylesheet.parentNode) {\r\n                stylesheet.parentNode.removeChild(stylesheet);\r\n            }\r\n        });\r\n        stylesheets.length = 0;\r\n    };\r\n    const beforeAddRead = (readFn) => {\r\n        _beforeAddReadFunctions.push(readFn);\r\n        return ani;\r\n    };\r\n    const beforeAddWrite = (writeFn) => {\r\n        _beforeAddWriteFunctions.push(writeFn);\r\n        return ani;\r\n    };\r\n    const afterAddRead = (readFn) => {\r\n        _afterAddReadFunctions.push(readFn);\r\n        return ani;\r\n    };\r\n    const afterAddWrite = (writeFn) => {\r\n        _afterAddWriteFunctions.push(writeFn);\r\n        return ani;\r\n    };\r\n    const beforeAddClass = (className) => {\r\n        beforeAddClasses = addClassToArray(beforeAddClasses, className);\r\n        return ani;\r\n    };\r\n    const beforeRemoveClass = (className) => {\r\n        beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);\r\n        return ani;\r\n    };\r\n    /**\r\n     * Set CSS inline styles to the animation's\r\n     * elements before the animation begins.\r\n     */\r\n    const beforeStyles = (styles = {}) => {\r\n        beforeStylesValue = styles;\r\n        return ani;\r\n    };\r\n    /**\r\n     * Clear CSS inline styles from the animation's\r\n     * elements before the animation begins.\r\n     */\r\n    const beforeClearStyles = (propertyNames = []) => {\r\n        for (const property of propertyNames) {\r\n            beforeStylesValue[property] = '';\r\n        }\r\n        return ani;\r\n    };\r\n    const afterAddClass = (className) => {\r\n        afterAddClasses = addClassToArray(afterAddClasses, className);\r\n        return ani;\r\n    };\r\n    const afterRemoveClass = (className) => {\r\n        afterRemoveClasses = addClassToArray(afterRemoveClasses, className);\r\n        return ani;\r\n    };\r\n    const afterStyles = (styles = {}) => {\r\n        afterStylesValue = styles;\r\n        return ani;\r\n    };\r\n    const afterClearStyles = (propertyNames = []) => {\r\n        for (const property of propertyNames) {\r\n            afterStylesValue[property] = '';\r\n        }\r\n        return ani;\r\n    };\r\n    const getFill = () => {\r\n        if (_fill !== undefined) {\r\n            return _fill;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getFill();\r\n        }\r\n        return 'both';\r\n    };\r\n    const getDirection = () => {\r\n        if (forceDirectionValue !== undefined) {\r\n            return forceDirectionValue;\r\n        }\r\n        if (_direction !== undefined) {\r\n            return _direction;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getDirection();\r\n        }\r\n        return 'normal';\r\n    };\r\n    const getEasing = () => {\r\n        if (shouldForceLinearEasing) {\r\n            return 'linear';\r\n        }\r\n        if (_easing !== undefined) {\r\n            return _easing;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getEasing();\r\n        }\r\n        return 'linear';\r\n    };\r\n    const getDuration = () => {\r\n        if (shouldForceSyncPlayback) {\r\n            return 0;\r\n        }\r\n        if (forceDurationValue !== undefined) {\r\n            return forceDurationValue;\r\n        }\r\n        if (_duration !== undefined) {\r\n            return _duration;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getDuration();\r\n        }\r\n        return 0;\r\n    };\r\n    const getIterations = () => {\r\n        if (_iterations !== undefined) {\r\n            return _iterations;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getIterations();\r\n        }\r\n        return 1;\r\n    };\r\n    const getDelay = () => {\r\n        if (forceDelayValue !== undefined) {\r\n            return forceDelayValue;\r\n        }\r\n        if (_delay !== undefined) {\r\n            return _delay;\r\n        }\r\n        if (parentAnimation) {\r\n            return parentAnimation.getDelay();\r\n        }\r\n        return 0;\r\n    };\r\n    const getKeyframes = () => {\r\n        return _keyframes;\r\n    };\r\n    const direction = (animationDirection) => {\r\n        _direction = animationDirection;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    const fill = (animationFill) => {\r\n        _fill = animationFill;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    const delay = (animationDelay) => {\r\n        _delay = animationDelay;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    const easing = (animationEasing) => {\r\n        _easing = animationEasing;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    const duration = (animationDuration) => {\r\n        /**\r\n         * CSS Animation Durations of 0ms work fine on Chrome\r\n         * but do not run on Safari, so force it to 1ms to\r\n         * get it to run on both platforms.\r\n         */\r\n        if (!supportsWebAnimations && animationDuration === 0) {\r\n            animationDuration = 1;\r\n        }\r\n        _duration = animationDuration;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    const iterations = (animationIterations) => {\r\n        _iterations = animationIterations;\r\n        update(true);\r\n        return ani;\r\n    };\r\n    const parent = (animation) => {\r\n        parentAnimation = animation;\r\n        return ani;\r\n    };\r\n    const addElement = (el) => {\r\n        if (el != null) {\r\n            if (el.nodeType === 1) {\r\n                elements.push(el);\r\n            }\r\n            else if (el.length >= 0) {\r\n                for (let i = 0; i < el.length; i++) {\r\n                    elements.push(el[i]);\r\n                }\r\n            }\r\n            else {\r\n                console.error('Invalid addElement value');\r\n            }\r\n        }\r\n        return ani;\r\n    };\r\n    const addAnimation = (animationToAdd) => {\r\n        if (animationToAdd != null) {\r\n            if (Array.isArray(animationToAdd)) {\r\n                for (const animation of animationToAdd) {\r\n                    animation.parent(ani);\r\n                    childAnimations.push(animation);\r\n                }\r\n            }\r\n            else {\r\n                animationToAdd.parent(ani);\r\n                childAnimations.push(animationToAdd);\r\n            }\r\n        }\r\n        return ani;\r\n    };\r\n    const keyframes = (keyframeValues) => {\r\n        const different = _keyframes !== keyframeValues;\r\n        _keyframes = keyframeValues;\r\n        if (different) {\r\n            updateKeyframes(_keyframes);\r\n        }\r\n        return ani;\r\n    };\r\n    const updateKeyframes = (keyframeValues) => {\r\n        if (supportsWebAnimations) {\r\n            getWebAnimations().forEach((animation) => {\r\n                /**\r\n                 * animation.effect's type is AnimationEffect.\r\n                 * However, in this case we have a more specific\r\n                 * type of AnimationEffect called KeyframeEffect which\r\n                 * inherits from AnimationEffect. As a result,\r\n                 * we cast animation.effect to KeyframeEffect.\r\n                 */\r\n                const keyframeEffect = animation.effect;\r\n                /**\r\n                 * setKeyframes is not supported in all browser\r\n                 * versions that Ionic supports, so we need to\r\n                 * check for support before using it.\r\n                 */\r\n                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n                if (keyframeEffect.setKeyframes) {\r\n                    keyframeEffect.setKeyframes(keyframeValues);\r\n                }\r\n                else {\r\n                    const newEffect = new KeyframeEffect(keyframeEffect.target, keyframeValues, keyframeEffect.getTiming());\r\n                    animation.effect = newEffect;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            initializeCSSAnimation();\r\n        }\r\n    };\r\n    /**\r\n     * Run all \"before\" animation hooks.\r\n     */\r\n    const beforeAnimation = () => {\r\n        // Runs all before read callbacks\r\n        _beforeAddReadFunctions.forEach((callback) => callback());\r\n        // Runs all before write callbacks\r\n        _beforeAddWriteFunctions.forEach((callback) => callback());\r\n        // Updates styles and classes before animation runs\r\n        const addClasses = beforeAddClasses;\r\n        const removeClasses = beforeRemoveClasses;\r\n        const styles = beforeStylesValue;\r\n        elements.forEach((el) => {\r\n            const elementClassList = el.classList;\r\n            addClasses.forEach((c) => elementClassList.add(c));\r\n            removeClasses.forEach((c) => elementClassList.remove(c));\r\n            for (const property in styles) {\r\n                // eslint-disable-next-line no-prototype-builtins\r\n                if (styles.hasOwnProperty(property)) {\r\n                    setStyleProperty(el, property, styles[property]);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Run all \"after\" animation hooks.\r\n     */\r\n    const afterAnimation = () => {\r\n        clearCSSAnimationsTimeout();\r\n        // Runs all after read callbacks\r\n        _afterAddReadFunctions.forEach((callback) => callback());\r\n        // Runs all after write callbacks\r\n        _afterAddWriteFunctions.forEach((callback) => callback());\r\n        // Updates styles and classes before animation ends\r\n        const currentStep = willComplete ? 1 : 0;\r\n        const addClasses = afterAddClasses;\r\n        const removeClasses = afterRemoveClasses;\r\n        const styles = afterStylesValue;\r\n        elements.forEach((el) => {\r\n            const elementClassList = el.classList;\r\n            addClasses.forEach((c) => elementClassList.add(c));\r\n            removeClasses.forEach((c) => elementClassList.remove(c));\r\n            for (const property in styles) {\r\n                // eslint-disable-next-line no-prototype-builtins\r\n                if (styles.hasOwnProperty(property)) {\r\n                    setStyleProperty(el, property, styles[property]);\r\n                }\r\n            }\r\n        });\r\n        /**\r\n         * Clean up any value coercion before\r\n         * the user callbacks fire otherwise\r\n         * they may get stale values. For example,\r\n         * if someone calls progressStart(0) the\r\n         * animation may still be reversed.\r\n         */\r\n        forceDurationValue = undefined;\r\n        forceDirectionValue = undefined;\r\n        forceDelayValue = undefined;\r\n        onFinishCallbacks.forEach((onFinishCallback) => {\r\n            return onFinishCallback.c(currentStep, ani);\r\n        });\r\n        onFinishOneTimeCallbacks.forEach((onFinishCallback) => {\r\n            return onFinishCallback.c(currentStep, ani);\r\n        });\r\n        onFinishOneTimeCallbacks.length = 0;\r\n        shouldCalculateNumAnimations = true;\r\n        if (willComplete) {\r\n            finished = true;\r\n        }\r\n        willComplete = true;\r\n    };\r\n    const animationFinish = () => {\r\n        if (numAnimationsRunning === 0) {\r\n            return;\r\n        }\r\n        numAnimationsRunning--;\r\n        if (numAnimationsRunning === 0) {\r\n            afterAnimation();\r\n            if (parentAnimation) {\r\n                parentAnimation.animationFinish();\r\n            }\r\n        }\r\n    };\r\n    const initializeCSSAnimation = (toggleAnimationName = true) => {\r\n        cleanUpStyleSheets();\r\n        const processedKeyframes = processKeyframes(_keyframes);\r\n        elements.forEach((element) => {\r\n            if (processedKeyframes.length > 0) {\r\n                const keyframeRules = generateKeyframeRules(processedKeyframes);\r\n                keyframeName = animationId !== undefined ? animationId : generateKeyframeName(keyframeRules);\r\n                const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);\r\n                stylesheets.push(stylesheet);\r\n                setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\r\n                setStyleProperty(element, 'animation-timing-function', getEasing());\r\n                setStyleProperty(element, 'animation-delay', `${getDelay()}ms`);\r\n                setStyleProperty(element, 'animation-fill-mode', getFill());\r\n                setStyleProperty(element, 'animation-direction', getDirection());\r\n                const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\r\n                setStyleProperty(element, 'animation-iteration-count', iterationsCount);\r\n                setStyleProperty(element, 'animation-play-state', 'paused');\r\n                if (toggleAnimationName) {\r\n                    setStyleProperty(element, 'animation-name', `${stylesheet.id}-alt`);\r\n                }\r\n                raf(() => {\r\n                    setStyleProperty(element, 'animation-name', stylesheet.id || null);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    const initializeWebAnimation = () => {\r\n        elements.forEach((element) => {\r\n            const animation = element.animate(_keyframes, {\r\n                id,\r\n                delay: getDelay(),\r\n                duration: getDuration(),\r\n                easing: getEasing(),\r\n                iterations: getIterations(),\r\n                fill: getFill(),\r\n                direction: getDirection(),\r\n            });\r\n            animation.pause();\r\n            webAnimations.push(animation);\r\n        });\r\n        if (webAnimations.length > 0) {\r\n            webAnimations[0].onfinish = () => {\r\n                animationFinish();\r\n            };\r\n        }\r\n    };\r\n    const initializeAnimation = (toggleAnimationName = true) => {\r\n        beforeAnimation();\r\n        if (_keyframes.length > 0) {\r\n            if (supportsWebAnimations) {\r\n                initializeWebAnimation();\r\n            }\r\n            else {\r\n                initializeCSSAnimation(toggleAnimationName);\r\n            }\r\n        }\r\n        initialized = true;\r\n    };\r\n    const setAnimationStep = (step) => {\r\n        step = Math.min(Math.max(step, 0), 0.9999);\r\n        if (supportsWebAnimations) {\r\n            webAnimations.forEach((animation) => {\r\n                // When creating the animation the delay is guaranteed to be set to a number.\r\n                animation.currentTime = animation.effect.getComputedTiming().delay + getDuration() * step;\r\n                animation.pause();\r\n            });\r\n        }\r\n        else {\r\n            const animationDuration = `-${getDuration() * step}ms`;\r\n            elements.forEach((element) => {\r\n                if (_keyframes.length > 0) {\r\n                    setStyleProperty(element, 'animation-delay', animationDuration);\r\n                    setStyleProperty(element, 'animation-play-state', 'paused');\r\n                }\r\n            });\r\n        }\r\n    };\r\n    const updateWebAnimation = (step) => {\r\n        webAnimations.forEach((animation) => {\r\n            animation.effect.updateTiming({\r\n                delay: getDelay(),\r\n                duration: getDuration(),\r\n                easing: getEasing(),\r\n                iterations: getIterations(),\r\n                fill: getFill(),\r\n                direction: getDirection(),\r\n            });\r\n        });\r\n        if (step !== undefined) {\r\n            setAnimationStep(step);\r\n        }\r\n    };\r\n    const updateCSSAnimation = (toggleAnimationName = true, step) => {\r\n        raf(() => {\r\n            elements.forEach((element) => {\r\n                setStyleProperty(element, 'animation-name', keyframeName || null);\r\n                setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\r\n                setStyleProperty(element, 'animation-timing-function', getEasing());\r\n                setStyleProperty(element, 'animation-delay', step !== undefined ? `-${step * getDuration()}ms` : `${getDelay()}ms`);\r\n                setStyleProperty(element, 'animation-fill-mode', getFill() || null);\r\n                setStyleProperty(element, 'animation-direction', getDirection() || null);\r\n                const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\r\n                setStyleProperty(element, 'animation-iteration-count', iterationsCount);\r\n                if (toggleAnimationName) {\r\n                    setStyleProperty(element, 'animation-name', `${keyframeName}-alt`);\r\n                }\r\n                raf(() => {\r\n                    setStyleProperty(element, 'animation-name', keyframeName || null);\r\n                });\r\n            });\r\n        });\r\n    };\r\n    const update = (deep = false, toggleAnimationName = true, step) => {\r\n        if (deep) {\r\n            childAnimations.forEach((animation) => {\r\n                animation.update(deep, toggleAnimationName, step);\r\n            });\r\n        }\r\n        if (supportsWebAnimations) {\r\n            updateWebAnimation(step);\r\n        }\r\n        else {\r\n            updateCSSAnimation(toggleAnimationName, step);\r\n        }\r\n        return ani;\r\n    };\r\n    const progressStart = (forceLinearEasing = false, step) => {\r\n        childAnimations.forEach((animation) => {\r\n            animation.progressStart(forceLinearEasing, step);\r\n        });\r\n        pauseAnimation();\r\n        shouldForceLinearEasing = forceLinearEasing;\r\n        if (!initialized) {\r\n            initializeAnimation();\r\n        }\r\n        update(false, true, step);\r\n        return ani;\r\n    };\r\n    const progressStep = (step) => {\r\n        childAnimations.forEach((animation) => {\r\n            animation.progressStep(step);\r\n        });\r\n        setAnimationStep(step);\r\n        return ani;\r\n    };\r\n    const progressEnd = (playTo, step, dur) => {\r\n        shouldForceLinearEasing = false;\r\n        childAnimations.forEach((animation) => {\r\n            animation.progressEnd(playTo, step, dur);\r\n        });\r\n        if (dur !== undefined) {\r\n            forceDurationValue = dur;\r\n        }\r\n        finished = false;\r\n        willComplete = true;\r\n        if (playTo === 0) {\r\n            forceDirectionValue = getDirection() === 'reverse' ? 'normal' : 'reverse';\r\n            if (forceDirectionValue === 'reverse') {\r\n                willComplete = false;\r\n            }\r\n            if (supportsWebAnimations) {\r\n                update();\r\n                setAnimationStep(1 - step);\r\n            }\r\n            else {\r\n                forceDelayValue = (1 - step) * getDuration() * -1;\r\n                update(false, false);\r\n            }\r\n        }\r\n        else if (playTo === 1) {\r\n            if (supportsWebAnimations) {\r\n                update();\r\n                setAnimationStep(step);\r\n            }\r\n            else {\r\n                forceDelayValue = step * getDuration() * -1;\r\n                update(false, false);\r\n            }\r\n        }\r\n        if (playTo !== undefined && !parentAnimation) {\r\n            play();\r\n        }\r\n        return ani;\r\n    };\r\n    const pauseAnimation = () => {\r\n        if (initialized) {\r\n            if (supportsWebAnimations) {\r\n                webAnimations.forEach((animation) => {\r\n                    animation.pause();\r\n                });\r\n            }\r\n            else {\r\n                elements.forEach((element) => {\r\n                    setStyleProperty(element, 'animation-play-state', 'paused');\r\n                });\r\n            }\r\n            paused = true;\r\n        }\r\n    };\r\n    const pause = () => {\r\n        childAnimations.forEach((animation) => {\r\n            animation.pause();\r\n        });\r\n        pauseAnimation();\r\n        return ani;\r\n    };\r\n    const onAnimationEndFallback = () => {\r\n        cssAnimationsTimerFallback = undefined;\r\n        animationFinish();\r\n    };\r\n    const clearCSSAnimationsTimeout = () => {\r\n        if (cssAnimationsTimerFallback) {\r\n            clearTimeout(cssAnimationsTimerFallback);\r\n        }\r\n    };\r\n    const playCSSAnimations = () => {\r\n        clearCSSAnimationsTimeout();\r\n        raf(() => {\r\n            elements.forEach((element) => {\r\n                if (_keyframes.length > 0) {\r\n                    setStyleProperty(element, 'animation-play-state', 'running');\r\n                }\r\n            });\r\n        });\r\n        if (_keyframes.length === 0 || elements.length === 0) {\r\n            animationFinish();\r\n        }\r\n        else {\r\n            /**\r\n             * This is a catchall in the event that a CSS Animation did not finish.\r\n             * The Web Animations API has mechanisms in place for preventing this.\r\n             * CSS Animations will not fire an `animationend` event\r\n             * for elements with `display: none`. The Web Animations API\r\n             * accounts for this, but using raw CSS Animations requires\r\n             * this workaround.\r\n             */\r\n            const animationDelay = getDelay() || 0;\r\n            const animationDuration = getDuration() || 0;\r\n            const animationIterations = getIterations() || 1;\r\n            // No need to set a timeout when animation has infinite iterations\r\n            if (isFinite(animationIterations)) {\r\n                cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration * animationIterations + ANIMATION_END_FALLBACK_PADDING_MS);\r\n            }\r\n            animationEnd(elements[0], () => {\r\n                clearCSSAnimationsTimeout();\r\n                /**\r\n                 * Ensure that clean up\r\n                 * is always done a frame\r\n                 * before the onFinish handlers\r\n                 * are fired. Otherwise, there\r\n                 * may be flickering if a new\r\n                 * animation is started on the same\r\n                 * element too quickly\r\n                 */\r\n                raf(() => {\r\n                    clearCSSAnimationPlayState();\r\n                    raf(animationFinish);\r\n                });\r\n            });\r\n        }\r\n    };\r\n    const clearCSSAnimationPlayState = () => {\r\n        elements.forEach((element) => {\r\n            removeStyleProperty(element, 'animation-duration');\r\n            removeStyleProperty(element, 'animation-delay');\r\n            removeStyleProperty(element, 'animation-play-state');\r\n        });\r\n    };\r\n    const playWebAnimations = () => {\r\n        webAnimations.forEach((animation) => {\r\n            animation.play();\r\n        });\r\n        if (_keyframes.length === 0 || elements.length === 0) {\r\n            animationFinish();\r\n        }\r\n    };\r\n    const resetAnimation = () => {\r\n        if (supportsWebAnimations) {\r\n            setAnimationStep(0);\r\n            updateWebAnimation();\r\n        }\r\n        else {\r\n            updateCSSAnimation();\r\n        }\r\n    };\r\n    const play = (opts) => {\r\n        return new Promise((resolve) => {\r\n            if (opts === null || opts === void 0 ? void 0 : opts.sync) {\r\n                shouldForceSyncPlayback = true;\r\n                onFinish(() => (shouldForceSyncPlayback = false), { oneTimeCallback: true });\r\n            }\r\n            if (!initialized) {\r\n                initializeAnimation();\r\n            }\r\n            if (finished) {\r\n                resetAnimation();\r\n                finished = false;\r\n            }\r\n            if (shouldCalculateNumAnimations) {\r\n                numAnimationsRunning = childAnimations.length + 1;\r\n                shouldCalculateNumAnimations = false;\r\n            }\r\n            /**\r\n             * When one of these callbacks fires we\r\n             * need to clear the other's callback otherwise\r\n             * you can potentially get these callbacks\r\n             * firing multiple times if the play method\r\n             * is subsequently called.\r\n             * Example:\r\n             * animation.play() (onStop and onFinish callbacks are registered)\r\n             * animation.stop() (onStop callback is fired, onFinish is not)\r\n             * animation.play() (onStop and onFinish callbacks are registered)\r\n             * Total onStop callbacks: 1\r\n             * Total onFinish callbacks: 2\r\n             */\r\n            const onStopCallback = () => {\r\n                clearCallback(onFinishCallback, onFinishOneTimeCallbacks);\r\n                resolve();\r\n            };\r\n            const onFinishCallback = () => {\r\n                clearCallback(onStopCallback, onStopOneTimeCallbacks);\r\n                resolve();\r\n            };\r\n            /**\r\n             * The play method resolves when an animation\r\n             * run either finishes or is cancelled.\r\n             */\r\n            onFinish(onFinishCallback, { oneTimeCallback: true });\r\n            onStop(onStopCallback, { oneTimeCallback: true });\r\n            childAnimations.forEach((animation) => {\r\n                animation.play();\r\n            });\r\n            if (supportsWebAnimations) {\r\n                playWebAnimations();\r\n            }\r\n            else {\r\n                playCSSAnimations();\r\n            }\r\n            paused = false;\r\n        });\r\n    };\r\n    /**\r\n     * Stops an animation and resets it state to the\r\n     * beginning. This does not fire any onFinish\r\n     * callbacks because the animation did not finish.\r\n     * However, since the animation was not destroyed\r\n     * (i.e. the animation could run again) we do not\r\n     * clear the onFinish callbacks.\r\n     */\r\n    const stop = () => {\r\n        childAnimations.forEach((animation) => {\r\n            animation.stop();\r\n        });\r\n        if (initialized) {\r\n            cleanUpElements();\r\n            initialized = false;\r\n        }\r\n        resetFlags();\r\n        onStopOneTimeCallbacks.forEach((onStopCallback) => onStopCallback.c(0, ani));\r\n        onStopOneTimeCallbacks.length = 0;\r\n    };\r\n    const from = (property, value) => {\r\n        const firstFrame = _keyframes[0];\r\n        if (firstFrame !== undefined && (firstFrame.offset === undefined || firstFrame.offset === 0)) {\r\n            firstFrame[property] = value;\r\n        }\r\n        else {\r\n            _keyframes = [{ offset: 0, [property]: value }, ..._keyframes];\r\n        }\r\n        return ani;\r\n    };\r\n    const to = (property, value) => {\r\n        const lastFrame = _keyframes[_keyframes.length - 1];\r\n        if (lastFrame !== undefined && (lastFrame.offset === undefined || lastFrame.offset === 1)) {\r\n            lastFrame[property] = value;\r\n        }\r\n        else {\r\n            _keyframes = [..._keyframes, { offset: 1, [property]: value }];\r\n        }\r\n        return ani;\r\n    };\r\n    const fromTo = (property, fromValue, toValue) => {\r\n        return from(property, fromValue).to(property, toValue);\r\n    };\r\n    return (ani = {\r\n        parentAnimation,\r\n        elements,\r\n        childAnimations,\r\n        id,\r\n        animationFinish,\r\n        from,\r\n        to,\r\n        fromTo,\r\n        parent,\r\n        play,\r\n        pause,\r\n        stop,\r\n        destroy,\r\n        keyframes,\r\n        addAnimation,\r\n        addElement,\r\n        update,\r\n        fill,\r\n        direction,\r\n        iterations,\r\n        duration,\r\n        easing,\r\n        delay,\r\n        getWebAnimations,\r\n        getKeyframes,\r\n        getFill,\r\n        getDirection,\r\n        getDelay,\r\n        getIterations,\r\n        getEasing,\r\n        getDuration,\r\n        afterAddRead,\r\n        afterAddWrite,\r\n        afterClearStyles,\r\n        afterStyles,\r\n        afterRemoveClass,\r\n        afterAddClass,\r\n        beforeAddRead,\r\n        beforeAddWrite,\r\n        beforeClearStyles,\r\n        beforeStyles,\r\n        beforeRemoveClass,\r\n        beforeAddClass,\r\n        onFinish,\r\n        isRunning,\r\n        progressStart,\r\n        progressStep,\r\n        progressEnd,\r\n    });\r\n};\r\n\r\nexport { createAnimation as c };\r\n"],"names":["animationPrefix","processKeyframes","keyframes","forEach","keyframe","key","hasOwnProperty","value","newKey","convertCamelCaseToHypen","str","replace","toLowerCase","getAnimationPrefix","el","undefined","supportsUnprefixed","style","animationName","supportsWebkitPrefix","webkitAnimationName","setStyleProperty","element","propertyName","prefix","startsWith","setProperty","removeStyleProperty","removeProperty","animationEnd","callback","unRegTrans","opts","passive","unregister","onTransitionEnd","ev","target","addEventListener","removeEventListener","generateKeyframeRules","map","offset","frameString","property","push","join","keyframeIds","generateKeyframeName","keyframeRules","index","indexOf","getStyleContainer","rootNode","getRootNode","head","createKeyframeStylesheet","keyframeName","_a","styleContainer","keyframePrefix","existingStylesheet","querySelector","stylesheet","ownerDocument","document","createElement","id","textContent","appendChild","addClassToArray","classes","className","classNameToAppend","Array","isArray","createAnimation","animationId","_delay","_duration","_easing","_iterations","_fill","_direction","parentAnimation","cssAnimationsTimerFallback","forceDirectionValue","forceDurationValue","forceDelayValue","ani","_keyframes","beforeAddClasses","beforeRemoveClasses","initialized","beforeStylesValue","afterAddClasses","afterRemoveClasses","afterStylesValue","numAnimationsRunning","shouldForceLinearEasing","shouldForceSyncPlayback","willComplete","finished","shouldCalculateNumAnimations","paused","onFinishCallbacks","onFinishOneTimeCallbacks","onStopOneTimeCallbacks","elements","childAnimations","stylesheets","_beforeAddReadFunctions","_beforeAddWriteFunctions","_afterAddReadFunctions","_afterAddWriteFunctions","webAnimations","supportsAnimationEffect","AnimationEffect","w","supportsWebAnimations","Element","prototype","animate","ANIMATION_END_FALLBACK_PADDING_MS","getWebAnimations","destroy","clearStyleSheets","childAnimation","cleanUp","length","clearOnFinish","cleanUpElements","cleanUpStyleSheets","resetFlags","isRunning","clearCallback","callbackToRemove","callbackObjects","findIndex","callbackObject","c","splice","onStop","o","onFinish","callbacks","oneTimeCallback","animation","cancel","elementsArray","slice","r","parentNode","removeChild","beforeAddRead","readFn","beforeAddWrite","writeFn","afterAddRead","afterAddWrite","beforeAddClass","beforeRemoveClass","beforeStyles","styles","beforeClearStyles","propertyNames","afterAddClass","afterRemoveClass","afterStyles","afterClearStyles","getFill","getDirection","getEasing","getDuration","getIterations","getDelay","getKeyframes","direction","animationDirection","update","fill","animationFill","delay","animationDelay","easing","animationEasing","duration","animationDuration","iterations","animationIterations","parent","addElement","nodeType","i","console","error","addAnimation","animationToAdd","keyframeValues","different","updateKeyframes","keyframeEffect","effect","setKeyframes","newEffect","KeyframeEffect","getTiming","initializeCSSAnimation","beforeAnimation","addClasses","removeClasses","elementClassList","classList","add","remove","afterAnimation","clearCSSAnimationsTimeout","currentStep","onFinishCallback","animationFinish","toggleAnimationName","processedKeyframes","iterationsCount","Infinity","toString","initializeWebAnimation","pause","onfinish","initializeAnimation","setAnimationStep","step","Math","min","max","currentTime","getComputedTiming","updateWebAnimation","updateTiming","updateCSSAnimation","deep","progressStart","forceLinearEasing","pauseAnimation","progressStep","progressEnd","playTo","dur","play","onAnimationEndFallback","clearTimeout","playCSSAnimations","isFinite","setTimeout","clearCSSAnimationPlayState","playWebAnimations","resetAnimation","Promise","resolve","sync","onStopCallback","stop","from","firstFrame","to","lastFrame","fromTo","fromValue","toValue"],"sourceRoot":""}