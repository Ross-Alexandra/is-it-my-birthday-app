{"version":3,"file":"js/775.c01512eb.js","mappings":"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","sources":["webpack://is-it-my-birthday/./node_modules/@ionic/core/components/index8.js","webpack://is-it-my-birthday/./node_modules/@ionic/core/components/input-shims.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { c as componentOnReady } from './helpers.js';\r\nimport { b as printRequiredElementError } from './index6.js';\r\n\r\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\r\nconst ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\r\nconst ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\r\n/**\r\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\r\n *\r\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\r\n * scroll events. With virtual scroll implementations this will be the host element for\r\n * the scroll viewport.\r\n */\r\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\r\nconst isIonContent = (el) => el.tagName === ION_CONTENT_TAG_NAME;\r\n/**\r\n * Waits for the element host fully initialize before\r\n * returning the inner scroll element.\r\n *\r\n * For `ion-content` the scroll target will be the result\r\n * of the `getScrollElement` function.\r\n *\r\n * For custom implementations it will be the element host\r\n * or a selector within the host, if supplied through `scrollTarget`.\r\n */\r\nconst getScrollElement = async (el) => {\r\n    if (isIonContent(el)) {\r\n        await new Promise((resolve) => componentOnReady(el, resolve));\r\n        return el.getScrollElement();\r\n    }\r\n    return el;\r\n};\r\n/**\r\n * Queries the element matching the selector for IonContent.\r\n * See ION_CONTENT_SELECTOR for the selector used.\r\n */\r\nconst findIonContent = (el) => {\r\n    /**\r\n     * First we try to query the custom scroll host selector in cases where\r\n     * the implementation is using an outer `ion-content` with an inner custom\r\n     * scroll container.\r\n     */\r\n    const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\r\n    if (customContentHost) {\r\n        return customContentHost;\r\n    }\r\n    return el.querySelector(ION_CONTENT_SELECTOR);\r\n};\r\n/**\r\n * Queries the closest element matching the selector for IonContent.\r\n */\r\nconst findClosestIonContent = (el) => {\r\n    return el.closest(ION_CONTENT_SELECTOR);\r\n};\r\n/**\r\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\r\n * using the public API `scrollToTop` with a duration.\r\n */\r\nconst scrollToTop = (el, durationMs) => {\r\n    if (isIonContent(el)) {\r\n        const content = el;\r\n        return content.scrollToTop(durationMs);\r\n    }\r\n    return Promise.resolve(el.scrollTo({\r\n        top: 0,\r\n        left: 0,\r\n        behavior: durationMs > 0 ? 'smooth' : 'auto',\r\n    }));\r\n};\r\n/**\r\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\r\n * using the public API `scrollByPoint` with a duration.\r\n */\r\nconst scrollByPoint = (el, x, y, durationMs) => {\r\n    if (isIonContent(el)) {\r\n        const content = el;\r\n        return content.scrollByPoint(x, y, durationMs);\r\n    }\r\n    return Promise.resolve(el.scrollBy({\r\n        top: y,\r\n        left: x,\r\n        behavior: durationMs > 0 ? 'smooth' : 'auto',\r\n    }));\r\n};\r\n/**\r\n * Prints an error informing developers that an implementation requires an element to be used\r\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\r\n */\r\nconst printIonContentErrorMsg = (el) => {\r\n    return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\r\n};\r\n/**\r\n * Several components in Ionic need to prevent scrolling\r\n * during a gesture (card modal, range, item sliding, etc).\r\n * Use this utility to account for ion-content and custom content hosts.\r\n */\r\nconst disableContentScrollY = (contentEl) => {\r\n    if (isIonContent(contentEl)) {\r\n        const ionContent = contentEl;\r\n        const initialScrollY = ionContent.scrollY;\r\n        ionContent.scrollY = false;\r\n        /**\r\n         * This should be passed into resetContentScrollY\r\n         * so that we can revert ion-content's scrollY to the\r\n         * correct state. For example, if scrollY = false\r\n         * initially, we do not want to enable scrolling\r\n         * when we call resetContentScrollY.\r\n         */\r\n        return initialScrollY;\r\n    }\r\n    else {\r\n        contentEl.style.setProperty('overflow', 'hidden');\r\n        return true;\r\n    }\r\n};\r\nconst resetContentScrollY = (contentEl, initialScrollY) => {\r\n    if (isIonContent(contentEl)) {\r\n        contentEl.scrollY = initialScrollY;\r\n    }\r\n    else {\r\n        contentEl.style.removeProperty('overflow');\r\n    }\r\n};\r\n\r\nexport { ION_CONTENT_CLASS_SELECTOR as I, findClosestIonContent as a, ION_CONTENT_ELEMENT_SELECTOR as b, scrollByPoint as c, disableContentScrollY as d, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, resetContentScrollY as r, scrollToTop as s };\r\n","/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win, d as doc } from './index5.js';\r\nimport { g as getScrollElement, c as scrollByPoint, a as findClosestIonContent } from './index8.js';\r\nimport { a as addEventListener, b as removeEventListener, r as raf, c as componentOnReady } from './helpers.js';\r\nimport { a as KeyboardResize, K as Keyboard } from './keyboard.js';\r\n\r\nconst cloneMap = new WeakMap();\r\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0, disabledClonedInput = false) => {\r\n    if (cloneMap.has(componentEl) === shouldRelocate) {\r\n        return;\r\n    }\r\n    if (shouldRelocate) {\r\n        addClone(componentEl, inputEl, inputRelativeY, disabledClonedInput);\r\n    }\r\n    else {\r\n        removeClone(componentEl, inputEl);\r\n    }\r\n};\r\nconst isFocused = (input) => {\r\n    /**\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode\r\n     * Calling getRootNode on an element in standard web page will return HTMLDocument.\r\n     * Calling getRootNode on an element inside of the Shadow DOM will return the associated ShadowRoot.\r\n     * Calling getRootNode on an element that is not attached to a document/shadow tree will return\r\n     * the root of the DOM tree it belongs to.\r\n     * isFocused is used for the hide-caret utility which only considers input/textarea elements\r\n     * that are present in the DOM, so we don't set types for that final case since it does not apply.\r\n     */\r\n    return input === input.getRootNode().activeElement;\r\n};\r\nconst addClone = (componentEl, inputEl, inputRelativeY, disabledClonedInput = false) => {\r\n    // this allows for the actual input to receive the focus from\r\n    // the user's touch event, but before it receives focus, it\r\n    // moves the actual input to a location that will not screw\r\n    // up the app's layout, and does not allow the native browser\r\n    // to attempt to scroll the input into place (messing up headers/footers)\r\n    // the cloned input fills the area of where native input should be\r\n    // while the native input fakes out the browser by relocating itself\r\n    // before it receives the actual focus event\r\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\r\n    const parentEl = inputEl.parentNode;\r\n    // DOM WRITES\r\n    const clonedEl = inputEl.cloneNode(false);\r\n    clonedEl.classList.add('cloned-input');\r\n    clonedEl.tabIndex = -1;\r\n    /**\r\n     * Making the cloned input disabled prevents\r\n     * Chrome for Android from still scrolling\r\n     * the entire page since this cloned input\r\n     * will briefly be hidden by the keyboard\r\n     * even though it is not focused.\r\n     *\r\n     * This is not needed on iOS. While this\r\n     * does not cause functional issues on iOS,\r\n     * the input still appears slightly dimmed even\r\n     * if we set opacity: 1.\r\n     */\r\n    if (disabledClonedInput) {\r\n        clonedEl.disabled = true;\r\n    }\r\n    parentEl.appendChild(clonedEl);\r\n    cloneMap.set(componentEl, clonedEl);\r\n    const doc = componentEl.ownerDocument;\r\n    const tx = doc.dir === 'rtl' ? 9999 : -9999;\r\n    componentEl.style.pointerEvents = 'none';\r\n    inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\r\n};\r\nconst removeClone = (componentEl, inputEl) => {\r\n    const clone = cloneMap.get(componentEl);\r\n    if (clone) {\r\n        cloneMap.delete(componentEl);\r\n        clone.remove();\r\n    }\r\n    componentEl.style.pointerEvents = '';\r\n    inputEl.style.transform = '';\r\n};\r\n/**\r\n * Factoring in 50px gives us some room\r\n * in case the keyboard shows password/autofill bars\r\n * asynchronously.\r\n */\r\nconst SCROLL_AMOUNT_PADDING = 50;\r\n\r\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\r\n    if (!scrollEl || !inputEl) {\r\n        return () => {\r\n            return;\r\n        };\r\n    }\r\n    const scrollHideCaret = (shouldHideCaret) => {\r\n        if (isFocused(inputEl)) {\r\n            relocateInput(componentEl, inputEl, shouldHideCaret);\r\n        }\r\n    };\r\n    const onBlur = () => relocateInput(componentEl, inputEl, false);\r\n    const hideCaret = () => scrollHideCaret(true);\r\n    const showCaret = () => scrollHideCaret(false);\r\n    addEventListener(scrollEl, 'ionScrollStart', hideCaret);\r\n    addEventListener(scrollEl, 'ionScrollEnd', showCaret);\r\n    inputEl.addEventListener('blur', onBlur);\r\n    return () => {\r\n        removeEventListener(scrollEl, 'ionScrollStart', hideCaret);\r\n        removeEventListener(scrollEl, 'ionScrollEnd', showCaret);\r\n        inputEl.removeEventListener('blur', onBlur);\r\n    };\r\n};\r\n\r\nconst SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';\r\nconst enableInputBlurring = () => {\r\n    let focused = true;\r\n    let didScroll = false;\r\n    const doc = document;\r\n    const onScroll = () => {\r\n        didScroll = true;\r\n    };\r\n    const onFocusin = () => {\r\n        focused = true;\r\n    };\r\n    const onTouchend = (ev) => {\r\n        // if app did scroll return early\r\n        if (didScroll) {\r\n            didScroll = false;\r\n            return;\r\n        }\r\n        const active = doc.activeElement;\r\n        if (!active) {\r\n            return;\r\n        }\r\n        // only blur if the active element is a text-input or a textarea\r\n        if (active.matches(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        // if the selected target is the active element, do not blur\r\n        const tapped = ev.target;\r\n        if (tapped === active) {\r\n            return;\r\n        }\r\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        focused = false;\r\n        // TODO FW-2796: find a better way, why 50ms?\r\n        setTimeout(() => {\r\n            if (!focused) {\r\n                active.blur();\r\n            }\r\n        }, 50);\r\n    };\r\n    addEventListener(doc, 'ionScrollStart', onScroll);\r\n    doc.addEventListener('focusin', onFocusin, true);\r\n    doc.addEventListener('touchend', onTouchend, false);\r\n    return () => {\r\n        removeEventListener(doc, 'ionScrollStart', onScroll, true);\r\n        doc.removeEventListener('focusin', onFocusin, true);\r\n        doc.removeEventListener('touchend', onTouchend, false);\r\n    };\r\n};\r\n\r\nconst SCROLL_ASSIST_SPEED = 0.3;\r\nconst getScrollData = (componentEl, contentEl, keyboardHeight, platformHeight) => {\r\n    var _a;\r\n    const itemEl = (_a = componentEl.closest('ion-item,[ion-item]')) !== null && _a !== void 0 ? _a : componentEl;\r\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, platformHeight);\r\n};\r\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\r\n    // compute input's Y values relative to the body\r\n    const inputTop = inputRect.top;\r\n    const inputBottom = inputRect.bottom;\r\n    // compute visible area\r\n    const visibleAreaTop = contentRect.top;\r\n    const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\r\n    // compute safe area\r\n    const safeAreaTop = visibleAreaTop + 15;\r\n    const safeAreaBottom = visibleAreaBottom - SCROLL_AMOUNT_PADDING;\r\n    // figure out if each edge of the input is within the safe area\r\n    const distanceToBottom = safeAreaBottom - inputBottom;\r\n    const distanceToTop = safeAreaTop - inputTop;\r\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\r\n    const desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0);\r\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\r\n    // gets focus, so make sure we don't scroll the input above the visible area\r\n    const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\r\n    const distance = Math.abs(scrollAmount);\r\n    const duration = distance / SCROLL_ASSIST_SPEED;\r\n    const scrollDuration = Math.min(400, Math.max(150, duration));\r\n    return {\r\n        scrollAmount,\r\n        scrollDuration,\r\n        scrollPadding: keyboardHeight,\r\n        inputSafeY: -(inputTop - safeAreaTop) + 4,\r\n    };\r\n};\r\n\r\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\r\n/**\r\n * Scroll padding adds additional padding to the bottom\r\n * of ion-content so that there is enough scroll space\r\n * for an input to be scrolled above the keyboard. This\r\n * is needed in environments where the webview does not\r\n * resize when the keyboard opens.\r\n *\r\n * Example: If an input at the bottom of ion-content is\r\n * focused, there is no additional scrolling space below\r\n * it, so the input cannot be scrolled above the keyboard.\r\n * Scroll padding fixes this by adding padding equal to the\r\n * height of the keyboard to the bottom of the content.\r\n *\r\n * Common environments where this is needed:\r\n * - Mobile Safari: The keyboard overlays the content\r\n * - Capacitor/Cordova on iOS: The keyboard overlays the content\r\n * when the KeyboardResize mode is set to 'none'.\r\n */\r\nconst setScrollPadding = (contentEl, paddingAmount, clearCallback) => {\r\n    const timer = contentEl[PADDING_TIMER_KEY];\r\n    if (timer) {\r\n        clearTimeout(timer);\r\n    }\r\n    if (paddingAmount > 0) {\r\n        contentEl.style.setProperty('--keyboard-offset', `${paddingAmount}px`);\r\n    }\r\n    else {\r\n        contentEl[PADDING_TIMER_KEY] = setTimeout(() => {\r\n            contentEl.style.setProperty('--keyboard-offset', '0px');\r\n            if (clearCallback) {\r\n                clearCallback();\r\n            }\r\n        }, 120);\r\n    }\r\n};\r\n/**\r\n * When an input is about to be focused,\r\n * set a timeout to clear any scroll padding\r\n * on the content. Note: The clearing\r\n * is done on a timeout so that if users\r\n * are moving focus from one input to the next\r\n * then re-adding scroll padding to the new\r\n * input with cancel the timeout to clear the\r\n * scroll padding.\r\n */\r\nconst setClearScrollPaddingListener = (inputEl, contentEl, doneCallback) => {\r\n    const clearScrollPadding = () => {\r\n        if (contentEl) {\r\n            setScrollPadding(contentEl, 0, doneCallback);\r\n        }\r\n    };\r\n    inputEl.addEventListener('focusout', clearScrollPadding, { once: true });\r\n};\r\n\r\nlet currentPadding = 0;\r\nconst SKIP_SCROLL_ASSIST = 'data-ionic-skip-scroll-assist';\r\nconst enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, keyboardResize, disableClonedInput = false) => {\r\n    /**\r\n     * Scroll padding should only be added if:\r\n     * 1. The global scrollPadding config option\r\n     * is set to true.\r\n     * 2. The native keyboard resize mode is either \"none\"\r\n     * (keyboard overlays webview) or undefined (resize\r\n     * information unavailable)\r\n     * Resize info is available on Capacitor 4+\r\n     */\r\n    const addScrollPadding = enableScrollPadding && (keyboardResize === undefined || keyboardResize.mode === KeyboardResize.None);\r\n    /**\r\n     * This tracks whether or not the keyboard has been\r\n     * presented for a single focused text field. Note\r\n     * that it does not track if the keyboard is open\r\n     * in general such as if the keyboard is open for\r\n     * a different focused text field.\r\n     */\r\n    let hasKeyboardBeenPresentedForTextField = false;\r\n    /**\r\n     * When adding scroll padding we need to know\r\n     * how much of the viewport the keyboard obscures.\r\n     * We do this by subtracting the keyboard height\r\n     * from the platform height.\r\n     *\r\n     * If we compute this value when switching between\r\n     * inputs then the webview may already be resized.\r\n     * At this point, `win.innerHeight` has already accounted\r\n     * for the keyboard meaning we would then subtract\r\n     * the keyboard height again. This will result in the input\r\n     * being scrolled more than it needs to.\r\n     */\r\n    const platformHeight = win !== undefined ? win.innerHeight : 0;\r\n    /**\r\n     * Scroll assist is run when a text field\r\n     * is focused. However, it may need to\r\n     * re-run when the keyboard size changes\r\n     * such that the text field is now hidden\r\n     * underneath the keyboard.\r\n     * This function re-runs scroll assist\r\n     * when that happens.\r\n     *\r\n     * One limitation of this is on a web browser\r\n     * where native keyboard APIs do not have cross-browser\r\n     * support. `ionKeyboardDidShow` relies on the Visual Viewport API.\r\n     * This means that if the keyboard changes but does not change\r\n     * geometry, then scroll assist will not re-run even if\r\n     * the user has scrolled the text field under the keyboard.\r\n     * This is not a problem when running in Cordova/Capacitor\r\n     * because `ionKeyboardDidShow` uses the native events\r\n     * which fire every time the keyboard changes.\r\n     */\r\n    const keyboardShow = (ev) => {\r\n        /**\r\n         * If the keyboard has not yet been presented\r\n         * for this text field then the text field has just\r\n         * received focus. In that case, the focusin listener\r\n         * will run scroll assist.\r\n         */\r\n        if (hasKeyboardBeenPresentedForTextField === false) {\r\n            hasKeyboardBeenPresentedForTextField = true;\r\n            return;\r\n        }\r\n        /**\r\n         * Otherwise, the keyboard has already been presented\r\n         * for the focused text field.\r\n         * This means that the keyboard likely changed\r\n         * geometry, and we need to re-run scroll assist.\r\n         * This can happen when the user rotates their device\r\n         * or when they switch keyboards.\r\n         *\r\n         * Make sure we pass in the computed keyboard height\r\n         * rather than the estimated keyboard height.\r\n         *\r\n         * Since the keyboard is already open then we do not\r\n         * need to wait for the webview to resize, so we pass\r\n         * \"waitForResize: false\".\r\n         */\r\n        jsSetFocus(componentEl, inputEl, contentEl, footerEl, ev.detail.keyboardHeight, addScrollPadding, disableClonedInput, platformHeight, false);\r\n    };\r\n    /**\r\n     * Reset the internal state when the text field loses focus.\r\n     */\r\n    const focusOut = () => {\r\n        hasKeyboardBeenPresentedForTextField = false;\r\n        win === null || win === void 0 ? void 0 : win.removeEventListener('ionKeyboardDidShow', keyboardShow);\r\n        componentEl.removeEventListener('focusout', focusOut, true);\r\n    };\r\n    /**\r\n     * When the input is about to receive\r\n     * focus, we need to move it to prevent\r\n     * mobile Safari from adjusting the viewport.\r\n     */\r\n    const focusIn = async () => {\r\n        /**\r\n         * Scroll assist should not run again\r\n         * on inputs that have been manually\r\n         * focused inside of the scroll assist\r\n         * implementation.\r\n         */\r\n        if (inputEl.hasAttribute(SKIP_SCROLL_ASSIST)) {\r\n            inputEl.removeAttribute(SKIP_SCROLL_ASSIST);\r\n            return;\r\n        }\r\n        jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight, addScrollPadding, disableClonedInput, platformHeight);\r\n        win === null || win === void 0 ? void 0 : win.addEventListener('ionKeyboardDidShow', keyboardShow);\r\n        componentEl.addEventListener('focusout', focusOut, true);\r\n    };\r\n    componentEl.addEventListener('focusin', focusIn, true);\r\n    return () => {\r\n        componentEl.removeEventListener('focusin', focusIn, true);\r\n        win === null || win === void 0 ? void 0 : win.removeEventListener('ionKeyboardDidShow', keyboardShow);\r\n        componentEl.removeEventListener('focusout', focusOut, true);\r\n    };\r\n};\r\n/**\r\n * Use this function when you want to manually\r\n * focus an input but not have scroll assist run again.\r\n */\r\nconst setManualFocus = (el) => {\r\n    /**\r\n     * If element is already focused then\r\n     * a new focusin event will not be dispatched\r\n     * to remove the SKIL_SCROLL_ASSIST attribute.\r\n     */\r\n    if (document.activeElement === el) {\r\n        return;\r\n    }\r\n    el.setAttribute(SKIP_SCROLL_ASSIST, 'true');\r\n    el.focus();\r\n};\r\nconst jsSetFocus = async (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, disableClonedInput = false, platformHeight = 0, waitForResize = true) => {\r\n    if (!contentEl && !footerEl) {\r\n        return;\r\n    }\r\n    const scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight, platformHeight);\r\n    if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {\r\n        // the text input is in a safe position that doesn't\r\n        // require it to be scrolled into view, just set focus now\r\n        setManualFocus(inputEl);\r\n        /**\r\n         * Even though the input does not need\r\n         * scroll assist, we should preserve the\r\n         * the scroll padding as users could be moving\r\n         * focus from an input that needs scroll padding\r\n         * to an input that does not need scroll padding.\r\n         * If we remove the scroll padding now, users will\r\n         * see the page jump.\r\n         */\r\n        if (enableScrollPadding && contentEl !== null) {\r\n            setScrollPadding(contentEl, currentPadding);\r\n            setClearScrollPaddingListener(inputEl, contentEl, () => (currentPadding = 0));\r\n        }\r\n        return;\r\n    }\r\n    // temporarily move the focus to the focus holder so the browser\r\n    // doesn't freak out while it's trying to get the input in place\r\n    // at this point the native text input still does not have focus\r\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY, disableClonedInput);\r\n    setManualFocus(inputEl);\r\n    /**\r\n     * Relocating/Focusing input causes the\r\n     * click event to be cancelled, so\r\n     * manually fire one here.\r\n     */\r\n    raf(() => componentEl.click());\r\n    /**\r\n     * If enabled, we can add scroll padding to\r\n     * the bottom of the content so that scroll assist\r\n     * has enough room to scroll the input above\r\n     * the keyboard.\r\n     */\r\n    if (enableScrollPadding && contentEl) {\r\n        currentPadding = scrollData.scrollPadding;\r\n        setScrollPadding(contentEl, currentPadding);\r\n    }\r\n    if (typeof window !== 'undefined') {\r\n        let scrollContentTimeout;\r\n        const scrollContent = async () => {\r\n            // clean up listeners and timeouts\r\n            if (scrollContentTimeout !== undefined) {\r\n                clearTimeout(scrollContentTimeout);\r\n            }\r\n            window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\r\n            window.removeEventListener('ionKeyboardDidShow', scrollContent);\r\n            // scroll the input into place\r\n            if (contentEl) {\r\n                await scrollByPoint(contentEl, 0, scrollData.scrollAmount, scrollData.scrollDuration);\r\n            }\r\n            // the scroll view is in the correct position now\r\n            // give the native text input focus\r\n            relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\r\n            // ensure this is the focused input\r\n            setManualFocus(inputEl);\r\n            /**\r\n             * When the input is about to be blurred\r\n             * we should set a timeout to remove\r\n             * any scroll padding.\r\n             */\r\n            if (enableScrollPadding) {\r\n                setClearScrollPaddingListener(inputEl, contentEl, () => (currentPadding = 0));\r\n            }\r\n        };\r\n        const doubleKeyboardEventListener = () => {\r\n            window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\r\n            window.addEventListener('ionKeyboardDidShow', scrollContent);\r\n        };\r\n        if (contentEl) {\r\n            const scrollEl = await getScrollElement(contentEl);\r\n            /**\r\n             * scrollData will only consider the amount we need\r\n             * to scroll in order to properly bring the input\r\n             * into view. It will not consider the amount\r\n             * we can scroll in the content element.\r\n             * As a result, scrollData may request a greater\r\n             * scroll position than is currently available\r\n             * in the DOM. If this is the case, we need to\r\n             * wait for the webview to resize/the keyboard\r\n             * to show in order for additional scroll\r\n             * bandwidth to become available.\r\n             */\r\n            const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\r\n            if (waitForResize && scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop) {\r\n                /**\r\n                 * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\r\n                 * after the initial keyboard is shown. This prevents the webview from resizing\r\n                 * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\r\n                 */\r\n                if (inputEl.type === 'password') {\r\n                    // Add 50px to account for the \"Passwords\" bar\r\n                    scrollData.scrollAmount += SCROLL_AMOUNT_PADDING;\r\n                    window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\r\n                }\r\n                else {\r\n                    window.addEventListener('ionKeyboardDidShow', scrollContent);\r\n                }\r\n                /**\r\n                 * This should only fire in 2 instances:\r\n                 * 1. The app is very slow.\r\n                 * 2. The app is running in a browser on an old OS\r\n                 * that does not support Ionic Keyboard Events\r\n                 */\r\n                scrollContentTimeout = setTimeout(scrollContent, 1000);\r\n                return;\r\n            }\r\n        }\r\n        scrollContent();\r\n    }\r\n};\r\n\r\nconst INPUT_BLURRING = true;\r\nconst startInputShims = async (config, platform) => {\r\n    /**\r\n     * If doc is undefined then we are in an SSR environment\r\n     * where input shims do not apply.\r\n     */\r\n    if (doc === undefined) {\r\n        return;\r\n    }\r\n    const isIOS = platform === 'ios';\r\n    const isAndroid = platform === 'android';\r\n    /**\r\n     * Hide Caret and Input Blurring are needed on iOS.\r\n     * Scroll Assist and Scroll Padding are needed on iOS and Android\r\n     * with Chrome web browser (not Chrome webview).\r\n     */\r\n    const keyboardHeight = config.getNumber('keyboardHeight', 290);\r\n    const scrollAssist = config.getBoolean('scrollAssist', true);\r\n    const hideCaret = config.getBoolean('hideCaretOnScroll', isIOS);\r\n    const inputBlurring = config.getBoolean('inputBlurring', isIOS);\r\n    const scrollPadding = config.getBoolean('scrollPadding', true);\r\n    const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\r\n    const hideCaretMap = new WeakMap();\r\n    const scrollAssistMap = new WeakMap();\r\n    /**\r\n     * Grab the native keyboard resize configuration\r\n     * and pass it to scroll assist. Scroll assist requires\r\n     * that we adjust the input right before the input\r\n     * is about to be focused. If we called `Keyboard.getResizeMode`\r\n     * on focusin in scroll assist, we could potentially adjust the\r\n     * input too late since this call is async.\r\n     */\r\n    const keyboardResizeMode = await Keyboard.getResizeMode();\r\n    const registerInput = async (componentEl) => {\r\n        await new Promise((resolve) => componentOnReady(componentEl, resolve));\r\n        const inputRoot = componentEl.shadowRoot || componentEl;\r\n        const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\r\n        const scrollEl = findClosestIonContent(componentEl);\r\n        const footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;\r\n        if (!inputEl) {\r\n            return;\r\n        }\r\n        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\r\n            const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\r\n            hideCaretMap.set(componentEl, rmFn);\r\n        }\r\n        /**\r\n         * date/datetime-locale inputs on mobile devices show date picker\r\n         * overlays instead of keyboards. As a result, scroll assist is\r\n         * not needed. This also works around a bug in iOS <16 where\r\n         * scroll assist causes the browser to lock up. See FW-1997.\r\n         */\r\n        const isDateInput = inputEl.type === 'date' || inputEl.type === 'datetime-local';\r\n        if (!isDateInput &&\r\n            (!!scrollEl || !!footerEl) &&\r\n            scrollAssist &&\r\n            !scrollAssistMap.has(componentEl)) {\r\n            const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight, scrollPadding, keyboardResizeMode, isAndroid);\r\n            scrollAssistMap.set(componentEl, rmFn);\r\n        }\r\n    };\r\n    const unregisterInput = (componentEl) => {\r\n        if (hideCaret) {\r\n            const fn = hideCaretMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            hideCaretMap.delete(componentEl);\r\n        }\r\n        if (scrollAssist) {\r\n            const fn = scrollAssistMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            scrollAssistMap.delete(componentEl);\r\n        }\r\n    };\r\n    if (inputBlurring && INPUT_BLURRING) {\r\n        enableInputBlurring();\r\n    }\r\n    // Input might be already loaded in the DOM before ion-device-hacks did.\r\n    // At this point we need to look for all of the inputs not registered yet\r\n    // and register them.\r\n    for (const input of inputs) {\r\n        registerInput(input);\r\n    }\r\n    doc.addEventListener('ionInputDidLoad', (ev) => {\r\n        registerInput(ev.detail);\r\n    });\r\n    doc.addEventListener('ionInputDidUnload', (ev) => {\r\n        unregisterInput(ev.detail);\r\n    });\r\n};\r\n\r\nexport { startInputShims };\r\n"],"names":["ION_CONTENT_TAG_NAME","ION_CONTENT_ELEMENT_SELECTOR","ION_CONTENT_CLASS_SELECTOR","ION_CONTENT_SELECTOR","isIonContent","el","tagName","getScrollElement","async","Promise","resolve","c","findClosestIonContent","closest","scrollToTop","durationMs","content","scrollTo","top","left","behavior","scrollByPoint","x","y","scrollBy","cloneMap","WeakMap","relocateInput","componentEl","inputEl","shouldRelocate","inputRelativeY","disabledClonedInput","has","addClone","removeClone","isFocused","input","getRootNode","activeElement","parentEl","parentNode","clonedEl","cloneNode","classList","add","tabIndex","disabled","appendChild","set","doc","ownerDocument","tx","dir","style","pointerEvents","transform","clone","get","delete","remove","SCROLL_AMOUNT_PADDING","enableHideCaretOnScroll","scrollEl","scrollHideCaret","shouldHideCaret","onBlur","hideCaret","showCaret","a","addEventListener","removeEventListener","SKIP_SELECTOR","enableInputBlurring","focused","didScroll","document","onScroll","onFocusin","onTouchend","ev","active","matches","tapped","target","setTimeout","blur","SCROLL_ASSIST_SPEED","getScrollData","contentEl","keyboardHeight","platformHeight","_a","itemEl","calcScrollData","getBoundingClientRect","inputRect","contentRect","inputTop","inputBottom","bottom","visibleAreaTop","visibleAreaBottom","Math","min","safeAreaTop","safeAreaBottom","distanceToBottom","distanceToTop","desiredScrollAmount","round","scrollAmount","distance","abs","duration","scrollDuration","max","scrollPadding","inputSafeY","PADDING_TIMER_KEY","setScrollPadding","paddingAmount","clearCallback","timer","clearTimeout","setProperty","setClearScrollPaddingListener","doneCallback","clearScrollPadding","once","currentPadding","SKIP_SCROLL_ASSIST","enableScrollAssist","footerEl","enableScrollPadding","keyboardResize","disableClonedInput","addScrollPadding","undefined","mode","None","hasKeyboardBeenPresentedForTextField","w","innerHeight","keyboardShow","jsSetFocus","detail","focusOut","focusIn","hasAttribute","removeAttribute","setManualFocus","setAttribute","focus","waitForResize","scrollData","r","click","window","scrollContentTimeout","scrollContent","doubleKeyboardEventListener","g","totalScrollAmount","scrollHeight","clientHeight","scrollTop","type","INPUT_BLURRING","startInputShims","config","platform","d","isIOS","isAndroid","getNumber","scrollAssist","getBoolean","inputBlurring","inputs","Array","from","querySelectorAll","hideCaretMap","scrollAssistMap","keyboardResizeMode","K","getResizeMode","registerInput","inputRoot","shadowRoot","querySelector","rmFn","isDateInput","unregisterInput","fn"],"sourceRoot":""}